OnAiTalk
{
	if CHAIN.IDName != ""
	{
		LastTalk = ChainTalk
	}
	else
	{
		if !UserAcceptedRole
		{
			if ghostupmin >= 60
			{
				"\t\*Have you acclimated yourself yet? We can begin our work if you have."
				"\n\n\_q"
				"\![*]\q[Yes,OnAcceptRole]  \![*]\q[No,OnNotAcceptRole]"
			}
			else; LastTalk = MonologueTalk.Parallel
		}
		else
		{
			if UniverseReady
			{
				LastTalk = RandomTalk
			}
			else
			{
				if UniverseReady
				{
					LastTalk = RandomTalk
				}
				else
				{
					if ARRAYSIZE(DialogueDisperser) <= 0
					{
						for _i = 0; _i  < 3; _i++
						{
							DialogueDisperser ,= "Normal"
						}
						DialogueDisperser ,= "Question"
					}
					
					_pick = ANY(DialogueDisperser)
					DialogueDisperser[LSO] = IARRAY
					
					if _pick == "Question"
					{
						LastTalk = QuestionTalk
						if LastTalk == "" //TODO this can be removed once we have 5 categories...
						{
							QuestionsAsked = 5
							LastTalk = RandomTalk
						}
					}
					else; LastTalk = RandomTalk
				}
			}
		}
	}
	LastTalk
}

RandomTalk : nonoverlap_pool
{
	"RandomTalk"
	
	if LastQuestions.MoreOrFewer.Animals != ""
	{
		_animal = LastQuestions.MoreOrFewer.Animals[0][0]
		_animals = LastQuestions.MoreOrFewer.Animals[0][1]
		_amount = LastQuestions.MoreOrFewer.Animals[1]
		
		if _amount == "more"
		{
			"So, how was it with more %(_animals)? I imagine things were quite lively?"
		}
		else //fewer
		{
			"So, did you miss the %(_animals)? I didn't leave very many of them in."
		}
	}
	
	if LastQuestions.ThisOrThat.Animals != ""
	{
		_animal_1 = LastQuestions.ThisOrThat.Animals[0][0]
		_animals_1 = LastQuestions.ThisOrThat.Animals[0][1]
		_animal_2 = LastQuestions.ThisOrThat.Animals[1][0]
		_animals_2 = LastQuestions.ThisOrThat.Animals[1][1]
		
		"So, did you enjoy the %(_animals_1)? Or would you rather have picked %(_animals_2) after all?"
	}
	
	parallel MonologueTalk
}

MonologueTalk : array
{
	"MonologueTalk"
}

QuestionTalk : nonoverlap_pool
{
	//More or fewer animals
	if Questions.MoreOrFewer.Animals == ""
	{
		_pick = animals
		_animal = _pick[0]
		_animals = _pick[1]
		
		"Do you think there should be more or fewer %(_animals)?"
		"How do you feel about %(_animals)? More or fewer?"
		//If you were an %(_animal), would you like more or fewer of your kind around? ← problem with this is, a/an...
		--
		"\n\n\![*]\q[More,OnQuestions,MoreOrFewer.Animals,""%(_pick)"",more]    \![*]\q[Fewer,OnQuestions,MoreOrFewer.Animals,""%(_pick)"",fewer]"
	}
	
	//This or that animal
	if Questions.ThisOrThat.Animals == ""
	{
		_pick1 = animals
		_pick2 = animals
		while _pick2 == _pick1
		{
			_pick2 = animals
		}
		_animal_1 = _pick1[0]
		_animals_1 = _pick1[1]
		_animal_2 = _pick2[0]
		_animals_2 = _pick2[1]
		
		"Would you prefer %(_animals_1) or %(_animals_2)?"
		"Do you think it would be better to include %(_animals_1) or %(_animals_2)?"
		--
		"\n\n\![*]\q[%(_animals_1),OnQuestions,ThisOrThat.Animals,""%(_pick1)"",""%(_pick2)""]    \![*]\q[%(_animals_2),OnQuestions,ThisOrThat.Animals,""%(_pick2)"",""%(_pick1)""]"
	}
}

OnQuestions
{
	_ref0 = reference[0]
	reference[0] = IARRAY
	NAMETOVALUE("Questions.%(_ref0) = reference")
	QuestionsAsked++
	
	"%(Questions.ThisOrThat.Animals)\n%(Questions.MoreOrFewer.Animals)\n\n"
	
	--
	if UniverseReady
	{
		"\0\b[0]\s[6]\tThen, that should do it for now. \n\n[half]\s[5]I have an idea of how this next universe will go, \s[1]as well as what I need to adjust for it to happen. \n\n[half]\s[7]Thank you for your contribution. \s[0]Let me know when you're ready and we can %(br)\_a[OnUniverseCreation.Begin]begin\_a.\x"
	}
	else
	{
		"Interesting..."
	}
}

OnUniverseCreation.Begin
{
	"\0\b[2]\s[5]\t'Begin', of course, means I'll be taking your feedback into account while I make the new universe for us. \n\n[half]\s[1]I'm afraid that you're not capable of doing it yourself, even if I were to let you try. \n\n[half]\s[8]Sorry about that. \n\n[half]\s[6]Still... \s[5]I'll do my best to honor each of your requests, \s[9]so please have faith in me. \n\n[half]\s[0]Let me know when you're ready. I won't rush you.\x"
}

MonologueTalk.Parallel : nonoverlap_pool
{
	parallel MonologueTalk
}